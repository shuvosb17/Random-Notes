<img width="1154" height="810" alt="image" src="https://github.com/user-attachments/assets/1903e160-4211-4546-aefc-8b2f294152d4" />

# ğŸ“˜ Complete Guide: Compiler Phases with Visual Examples

Let me break down the three major phases of compilation with crystal-clear visualizations and code examples!

---

## ğŸ¯ **BIG PICTURE: How Code Gets Compiled**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SOURCE CODE COMPILATION PROCESS                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                    Your Code: int x = 5;
                            â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                   â”‚                   â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
   â”‚ LEXICAL â”‚         â”‚ SYNTAX  â”‚        â”‚SEMANTIC â”‚
   â”‚ANALYSIS â”‚    â†’    â”‚ANALYSIS â”‚   â†’    â”‚ANALYSIS â”‚
   â”‚(Scanner)â”‚         â”‚(Parser) â”‚        â”‚(Checker)â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”‚                   â”‚                   â”‚
        â–¼                   â–¼                   â–¼
    TOKENS            SYNTAX TREE          VALIDATED CODE
    [int][x][=][5]    Grammar Check        Meaning Check
```

**Simple Analogy:**
```
Writing an Essay:

1. LEXICAL   = Spell-check individual words
2. SYNTAX    = Check grammar/sentence structure  
3. SEMANTIC  = Check if sentences make logical sense
```

---

## ğŸ” **PHASE 1: LEXICAL ANALYSIS (Token Formation)**

### **What It Does:**
Breaks source code into **tokens** (smallest meaningful units) like words in a sentence.

---

### **Visual Process:**

```
INPUT (Source Code):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  int sum = a + 5;            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼ LEXICAL ANALYZER (SCANNER)
         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
    â”‚          â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
    â–¼          â–¼     â–¼     â–¼     â–¼     â–¼     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”
â”‚ int  â”‚  â”‚ sum â”‚ â”‚ = â”‚ â”‚ a â”‚ â”‚ + â”‚ â”‚ 5 â”‚ â”‚ ; â”‚
â”‚KEYWORDâ”‚ â”‚ ID  â”‚ â”‚OP â”‚ â”‚ IDâ”‚ â”‚OP â”‚ â”‚NUMâ”‚ â”‚DELâ”‚
â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜
```

**Token Categories:**

| Token Type | Examples | Description |
|------------|----------|-------------|
| **KEYWORD** | `int`, `if`, `while`, `return` | Reserved words |
| **IDENTIFIER** | `sum`, `myVar`, `count` | Variable/function names |
| **OPERATOR** | `+`, `-`, `*`, `/`, `=` | Math/logical operators |
| **LITERAL** | `5`, `3.14`, `"hello"` | Constant values |
| **DELIMITER** | `;`, `{`, `}`, `,` | Punctuation symbols |

---

### **Example 1: Valid Code**

```c
int main() {
    int age = 25;
    return 0;
}
```

**Tokenization:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Token Stream                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Token      â”‚ Lexeme                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ KEYWORD    â”‚ int                                         â”‚
â”‚ IDENTIFIER â”‚ main                                        â”‚
â”‚ DELIMITER  â”‚ (                                           â”‚
â”‚ DELIMITER  â”‚ )                                           â”‚
â”‚ DELIMITER  â”‚ {                                           â”‚
â”‚ KEYWORD    â”‚ int                                         â”‚
â”‚ IDENTIFIER â”‚ age                                         â”‚
â”‚ OPERATOR   â”‚ =                                           â”‚
â”‚ LITERAL    â”‚ 25                                          â”‚
â”‚ DELIMITER  â”‚ ;                                           â”‚
â”‚ KEYWORD    â”‚ return                                      â”‚
â”‚ LITERAL    â”‚ 0                                           â”‚
â”‚ DELIMITER  â”‚ ;                                           â”‚
â”‚ DELIMITER  â”‚ }                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Example 2: Invalid Characters**

#### **Error Case 1: Illegal Characters**

```c
int x = 5@;
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LEXICAL ANALYSIS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ int  â†’ âœ… KEYWORD                        â”‚
â”‚ x    â†’ âœ… IDENTIFIER                     â”‚
â”‚ =    â†’ âœ… OPERATOR                       â”‚
â”‚ 5    â†’ âœ… LITERAL                        â”‚
â”‚ @    â†’ âŒ ERROR: Invalid character       â”‚
â”‚ ;    â†’ âœ… DELIMITER                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 1, Column 10:                       â”‚
â”‚ Illegal character '@'                    â”‚
â”‚ Expected: operator, delimiter, or letter â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int x = 5;  // Remove '@'
```

---

#### **Error Case 2: Invalid Identifier**

```c
int 2variable = 10;
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LEXICAL ANALYSIS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ int       â†’ âœ… KEYWORD                   â”‚
â”‚ 2variable â†’ âŒ ERROR: Cannot start with  â”‚
â”‚              digit                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 1, Column 5:                        â”‚
â”‚ Invalid identifier '2variable'           â”‚
â”‚ Identifiers must start with letter or _  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Valid Identifier Rules:**

```
âœ… CORRECT IDENTIFIERS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ myVar                   â”‚
â”‚ _count                  â”‚
â”‚ sum2                    â”‚
â”‚ MaxValue                â”‚
â”‚ user_input              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âŒ INCORRECT IDENTIFIERS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2ndValue    (starts with digit)
â”‚ my-var      (contains hyphen)
â”‚ int         (keyword)
â”‚ user name   (contains space)
â”‚ @value      (starts with symbol)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int variable2 = 10;  // Put digit AFTER letters
```

---

#### **Error Case 3: Unterminated String**

```c
char* name = "John
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LEXICAL ANALYSIS                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ char  â†’ âœ… KEYWORD                       â”‚
â”‚ *     â†’ âœ… OPERATOR                      â”‚
â”‚ name  â†’ âœ… IDENTIFIER                    â”‚
â”‚ =     â†’ âœ… OPERATOR                      â”‚
â”‚ "John â†’ âŒ ERROR: Missing closing "      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 1:                                  â”‚
â”‚ Unterminated string literal              â”‚
â”‚ Expected closing quote (")               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
char* name = "John";  // Add closing quote
```

---

### **Visual: How Scanner Works**

```
CHARACTER STREAM â†’ SCANNER â†’ TOKEN STREAM
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Input: "int x = 5;"

Step-by-step:
â”Œâ”€â”€â”€â”
â”‚ i â”‚ â† Read character
â””â”€â”¬â”€â”˜
  â”‚ Buffer: "i"
â”Œâ”€â–¼â”€â”
â”‚ n â”‚ â† Read next
â””â”€â”¬â”€â”˜
  â”‚ Buffer: "in"
â”Œâ”€â–¼â”€â”
â”‚ t â”‚ â† Read next
â””â”€â”¬â”€â”˜
  â”‚ Buffer: "int"
â”Œâ”€â–¼â”€â”
â”‚   â”‚ â† Space found! Create token
â””â”€â”€â”€â”˜
  â”‚ Token: <KEYWORD, "int">
  â”‚ Clear buffer
  â–¼
Continue for next characters...
```

---

## ğŸŒ³ **PHASE 2: SYNTAX ANALYSIS (Grammar Checking)**

### **What It Does:**
Checks if tokens follow **grammar rules** and builds a **parse tree** (structure).

---

### **Visual Process:**

```
TOKEN STREAM:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚int â”‚ x  â”‚ = â”‚ 5 â”‚ + â”‚ 3 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
        â”‚
        â–¼ SYNTAX ANALYZER (PARSER)
        â”‚
        â–¼ Builds Parse Tree:

        Assignment
           â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚             â”‚
    x         Expression
              â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
              5    +    3
```

**Grammar Rules Example (Simplified):**

```
GRAMMAR RULES:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Statement    â†’ Type Identifier = Expression ;
Type         â†’ int | float | char
Identifier   â†’ [a-zA-Z_][a-zA-Z0-9_]*
Expression   â†’ Number | Identifier | Expression + Expression
Number       â†’ [0-9]+
```

---

### **Example 3: Valid Syntax**

```c
int sum = a + b;
```

**Parse Tree:**

```
              Statement
                 â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚        â”‚        â”‚
       int      sum    Assignment
                        â”‚
                  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
                  =         Expression
                            â”‚
                        â”Œâ”€â”€â”€â”´â”€â”€â”€â”
                        a   +   b
```

**Syntax Check:** âœ… **PASS**
- Has type (`int`)
- Has identifier (`sum`)
- Has assignment operator (`=`)
- Has expression (`a + b`)
- Has semicolon (`;`)

---

### **Example 4: Missing Semicolon**

```c
int x = 5
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SYNTAX ANALYSIS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Expected: Statement â†’ Type ID = Expr ;   â”‚
â”‚                                          â”‚
â”‚ Found:    int x = 5 [END]                â”‚
â”‚           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ âŒ Missing ;       
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 1:                                  â”‚
â”‚ Syntax error: Expected ';' after         â”‚
â”‚ expression                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int x = 5;  // Add semicolon
```

---

### **Example 5: Misplaced Operator**

```c
int x = + 5;
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SYNTAX ANALYSIS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Expected: Expression â†’ Number | ID       â”‚
â”‚           Expression â†’ Expr + Expr       â”‚
â”‚                                          â”‚
â”‚ Found:    = + 5                          â”‚
â”‚             â”€ âŒ Operator without left   
â”‚                  operand                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 1:                                  â”‚
â”‚ Syntax error: Unexpected '+' operator    â”‚
â”‚ Expected: identifier or literal          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int x = 5;      // Remove extra +
// OR
int x = +5;     // Unary plus (valid)
// OR
int x = a + 5;  // Binary plus (valid)
```

---

### **Example 6: Unbalanced Brackets**

```c
int main() {
    int x = 5;
// Missing closing brace
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SYNTAX ANALYSIS                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Expected: Function â†’ Type ID () { ... }  â”‚
â”‚                                          â”‚
â”‚ Found:    int main() { int x = 5; [EOF]  â”‚
â”‚                      â”€           âŒ      
â”‚                      â””â”€ Unclosed brace   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 3:                                  â”‚
â”‚ Syntax error: Expected '}' to close      â”‚
â”‚ block starting at line 1                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int main() {
    int x = 5;
}  // Add closing brace
```

---

### **Visual: Parser Stack**

```
Parsing: int x = 5;

STACK (Bottom to Top):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Step 1:
â”Œâ”€â”€â”€â”€â”
â”‚int â”‚ â† Push keyword
â””â”€â”€â”€â”€â”˜

Step 2:
â”Œâ”€â”€â”€â”€â”
â”‚ x  â”‚ â† Push identifier
â”œâ”€â”€â”€â”€â”¤
â”‚int â”‚
â””â”€â”€â”€â”€â”˜

Step 3:
â”Œâ”€â”€â”€â”€â”
â”‚ =  â”‚ â† Reduce: Type + ID â†’ Declaration
â”œâ”€â”€â”€â”€â”¤
â”‚Declâ”‚
â””â”€â”€â”€â”€â”˜

Step 4:
â”Œâ”€â”€â”€â”€â”
â”‚ 5  â”‚ â† Push number
â”œâ”€â”€â”€â”€â”¤
â”‚ =  â”‚
â”œâ”€â”€â”€â”€â”¤
â”‚Declâ”‚
â””â”€â”€â”€â”€â”˜

Step 5:
â”Œâ”€â”€â”€â”€â”
â”‚ ;  â”‚ â† Reduce all â†’ Statement
â”œâ”€â”€â”€â”€â”¤
â”‚Stmtâ”‚ âœ… ACCEPT
â””â”€â”€â”€â”€â”˜
```

---

## âœ… **PHASE 3: SEMANTIC ANALYSIS (Meaning Checking)**

### **What It Does:**
Checks if the code **makes logical sense** (types, declarations, scope).

---

### **Visual Process:**

```
PARSE TREE:
    Assignment
       â”‚
   â”Œâ”€â”€â”€â”´â”€â”€â”€â”
   x   =   5
   â”‚       â”‚
   â–¼       â–¼
SEMANTIC ANALYZER checks:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Is 'x' declared? âœ…   
â”‚ 2. Type of 'x'? int      â”‚
â”‚ 3. Type of '5'? int      â”‚
â”‚ 4. int = int? âœ… Match!  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Example 7: Undeclared Variable**

```c
int main() {
    x = 5;  // 'x' never declared
    return 0;
}
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEMANTIC ANALYSIS                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Checking: x = 5;                         â”‚
â”‚                                          â”‚
â”‚ Symbol Table (current scope):            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚ â”‚ Name     â”‚ Type â”‚ Scope â”‚              â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤              â”‚
â”‚ â”‚ (empty)  â”‚      â”‚       â”‚              â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                          â”‚
â”‚ âŒ Variable 'x' not found in table       
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 2:                                  â”‚
â”‚ Semantic error: 'x' undeclared           â”‚
â”‚ (first use in this function)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int main() {
    int x;   // Declare 'x'
    x = 5;
    return 0;
}
```

---

### **Example 8: Type Mismatch**

```c
int x = "hello";
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEMANTIC ANALYSIS                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Checking: int x = "hello";               â”‚
â”‚                                          â”‚
â”‚ Left side:  int                          â”‚
â”‚ Right side: char* (string)               â”‚
â”‚                                          â”‚
â”‚ Type compatibility:                      â”‚
â”‚ int â‰  char* âŒ MISMATCH                  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 1:                                  â”‚
â”‚ Semantic error: Cannot convert           â”‚
â”‚ 'const char*' to 'int'                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
char* x = "hello";  // Use correct type
// OR
int x = 42;         // Use integer value
```

---

### **Example 9: Scope Error**

```c
int main() {
    {
        int x = 5;
    }
    x = 10;  // 'x' out of scope
}
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEMANTIC ANALYSIS                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Symbol Table (nested scopes):            â”‚
â”‚                                          â”‚
â”‚ Scope 0 (main):                          â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚ â”‚ Name     â”‚ Type â”‚                      â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤                      â”‚
â”‚ â”‚ (empty)  â”‚      â”‚                      â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                          â”‚
â”‚ Scope 1 (inner block):                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚ â”‚ x        â”‚ int  â”‚ â† Defined here       â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                   â†‘                      â”‚
â”‚                   â””â”€ Destroyed when }    â”‚
â”‚                                          â”‚
â”‚ Line 5: Trying to use 'x' in Scope 0     â”‚
â”‚ âŒ 'x' not found in current scope        
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 5:                                  â”‚
â”‚ Semantic error: 'x' undeclared in this   â”‚
â”‚ scope                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int main() {
    int x;       // Declare in main scope
    {
        x = 5;   // Use x
    }
    x = 10;      // Still in scope âœ…
}
```

---

### **Example 10: Redeclaration**

```c
int x = 5;
int x = 10;
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEMANTIC ANALYSIS                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Symbol Table:                            â”‚
â”‚                                          â”‚
â”‚ Line 1: Add 'x' (int) âœ…                 
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚ â”‚ x        â”‚ int  â”‚                      â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                          â”‚
â”‚ Line 2: Try to add 'x' (int) again       â”‚
â”‚         âŒ CONFLICT: Name already exists 
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 2:                                  â”‚
â”‚ Semantic error: Redeclaration of 'x'     â”‚
â”‚ Previous declaration at line 1           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
int x = 5;
x = 10;      // Just reassign (no 'int')
```

---

### **Example 11: Function Call Mismatch**

```c
void printNum(int n) {
    printf("%d", n);
}

int main() {
    printNum("hello");  // Wrong type
}
```

**What Happens:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SEMANTIC ANALYSIS                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Function signature:                      â”‚
â”‚ printNum(int) â†’ void                     â”‚
â”‚                                          â”‚
â”‚ Call at line 6:                          â”‚
â”‚ printNum("hello")                        â”‚
â”‚          â”€â”€â”€â”€â”€â”€â”€ char*                   â”‚
â”‚                                          â”‚
â”‚ Parameter check:                         â”‚
â”‚ Expected: int                            â”‚
â”‚ Got:      char*                          â”‚
â”‚ âŒ TYPE MISMATCH                        
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ERROR MESSAGE:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Line 6:                                  â”‚
â”‚ Semantic error: Cannot convert argument  â”‚
â”‚ 1 from 'const char*' to 'int'            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Fix:**
```c
printNum(42);  // Pass integer
```

---

### **Symbol Table Visualization:**

```
SYMBOL TABLE (Hash Table Structure):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
After: int x = 5; float y = 3.14;

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Name   â”‚ Type â”‚ Scopeâ”‚ Line  â”‚ Address â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x      â”‚ int  â”‚ 0    â”‚ 1     â”‚ 0x1000  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ y      â”‚ floatâ”‚ 0    â”‚ 2     â”‚ 0x1004  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Lookup 'x' â†’ Found âœ…
Lookup 'z' â†’ Not found âŒ
```

---

## ğŸ“Š **COMPLETE COMPARISON TABLE**

| Phase | Input | Output | What It Checks | Common Errors | Fix Strategy |
|-------|-------|--------|----------------|---------------|--------------|
| **Lexical** | Source code | Token stream | Valid characters, identifiers | `@` in code, `2var`, unterminated string | Remove invalid chars, rename variables |
| **Syntax** | Tokens | Parse tree | Grammar rules | Missing `;`, `{` without `}`, misplaced operators | Add missing symbols, balance brackets |
| **Semantic** | Parse tree | Annotated tree | Meaning/logic | Undeclared vars, type mismatch, scope errors | Declare variables, fix types, check scope |

---

## ğŸ”„ **COMPLETE EXAMPLE: All Three Phases**

### **Source Code:**

```c
int main() {
    int x = 5;
    float y = x + 3.14;
    return 0;
}
```

---

### **PHASE 1: LEXICAL ANALYSIS**

```
TOKEN STREAM:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Keyword  â”‚ int    â”‚ int    â”‚ float  â”‚ return â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ID       â”‚ main   â”‚ x      â”‚ y      â”‚        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Delimiterâ”‚ (){}   â”‚ ;      â”‚ ;      â”‚ ;      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Operator â”‚        â”‚ =      â”‚ = +    â”‚        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Literal  â”‚        â”‚ 5      â”‚ 3.14   â”‚ 0      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

âœ… No lexical errors
```

---

### **PHASE 2: SYNTAX ANALYSIS**

```
PARSE TREE:

            Program
               â”‚
           Function
               â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚      â”‚          â”‚
       int   main()    Block
                          â”‚
                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                  â”‚       â”‚        â”‚
             Statement Statement Return
                  â”‚       â”‚        â”‚
             â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”   â”‚        0
            int  x = 5    â”‚
                     â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
                   float  y = Expr
                              â”‚
                          â”Œâ”€â”€â”€â”´â”€â”€â”€â”
                          x   +   3.14

âœ… No syntax errors
```

---

### **PHASE 3: SEMANTIC ANALYSIS**

```
SYMBOL TABLE:
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Name â”‚ Type  â”‚ Scope â”‚ Value  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ main â”‚ int() â”‚ 0     â”‚ func   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ x    â”‚ int   â”‚ 1     â”‚ 5      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ y    â”‚ float â”‚ 1     â”‚ 8.14   â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TYPE CHECKS:
1. x = 5        â†’ int = int âœ…
2. y = x + 3.14 â†’ float = int + float
                â†’ float = float âœ… (int promoted)
3. return 0     â†’ int (matches main's type) âœ…

âœ… No semantic errors
```

---

## ğŸ¯ **SUMMARY: One-Sentence Each**

1. **Lexical Analysis** = Breaks code into valid words (tokens) and rejects invalid characters.
2. **Syntax Analysis** = Checks if words follow grammar rules and builds structure.
3. **Semantic Analysis** = Ensures code makes logical sense (types match, variables exist).

---

## ğŸ§  **MEMORY TRICK: "LSS"**

```
L = LEXICAL   â†’ "Letters & Symbols" (character-level)
S = SYNTAX    â†’ "Structure"         (grammar-level)
S = SEMANTIC  â†’ "Sense/Meaning"     (logic-level)
```

---

## âœ… **Quick Debug Checklist**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ERROR TYPE      â”‚ LOOK FOR               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Lexical         â”‚ â€¢ Weird symbols        â”‚
â”‚                 â”‚ â€¢ Numbers starting IDs â”‚
â”‚                 â”‚ â€¢ Missing quotes       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Syntax          â”‚ â€¢ Missing ; { }        â”‚
â”‚                 â”‚ â€¢ Unbalanced ()        â”‚
â”‚                 â”‚ â€¢ Operators alone      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Semantic        â”‚ â€¢ Undeclared variables â”‚
â”‚                 â”‚ â€¢ Type mismatches      â”‚
â”‚                 â”‚ â€¢ Scope issues         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

**ğŸ“ You now understand compiler phases like a pro! Good luck with your exam! ğŸ’»âœ¨**



# ğŸš¨ Error Recovery in Compilers â€” Focus on Panic Mode

---

## ğŸ¯ **BIG PICTURE: Why Error Recovery?**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        WITHOUT ERROR RECOVERY                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Line 5: Missing semicolon                          â”‚
â”‚  âŒ COMPILATION STOPPED                             
â”‚  (Lines 6-100 not checked)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        WITH ERROR RECOVERY                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Line 5: Missing semicolon âš ï¸                       â”‚
â”‚  âœ… Continue checking...                            â”‚
â”‚  Line 12: Type mismatch âš ï¸                          â”‚
â”‚  Line 25: Undeclared variable âš ï¸                    â”‚
â”‚  Total: 3 errors found                              
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Goal:** Find **multiple errors** in one compilation pass instead of stopping at the first error.

---

## ğŸ“š **ERROR RECOVERY STRATEGIES (Quick Overview)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ERROR RECOVERY METHODS                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚            â”‚            â”‚          â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
   â”‚ PANIC   â”‚  â”‚ PHRASE  â”‚  â”‚ ERROR â”‚  â”‚GLOBAL â”‚
   â”‚  MODE   â”‚  â”‚  LEVEL  â”‚  â”‚PRODUC.â”‚  â”‚CORREC.â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”€â”¬â”€â”€â”€â”˜
        â”‚            â”‚            â”‚          â”‚
     SIMPLE      SMARTER       GRAMMAR    COMPLEX
     FAST        SLOWER        SPECIFIC   SLOW
```

| Method | How It Works | Speed | Accuracy |
|--------|--------------|-------|----------|
| **Panic Mode** | Skip tokens until safe point | âš¡ Fast | â­ Basic |
| **Phrase Level** | Local corrections (insert/delete) | ğŸ¢ Medium | â­â­ Better |
| **Error Productions** | Add error rules to grammar | ğŸ¢ Medium | â­â­ Good |
| **Global Correction** | Find minimal changes needed | ğŸŒ Slow | â­â­â­ Best |

**We'll focus on PANIC MODE** (most common in real compilers).

---

## ğŸ”¥ **PANIC MODE RECOVERY â€” Deep Dive**

### **Core Concept:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PANIC MODE STRATEGY                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Encounter error âŒ                                â”‚
â”‚ 2. PANIC! Discard tokens ğŸ—‘ï¸                          â”‚
â”‚ 3. Find "synchronization point" ğŸ“                   â”‚
â”‚ 4. Resume parsing âœ…                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Visual Analogy:**

```
Reading a book with a torn page:

Normal: Read page 1 â†’ torn page 2 â†’ STOP âŒ

Panic Mode:
  Read page 1 
    â†’ torn page 2 (skip it!) 
    â†’ Find Chapter 3 heading ğŸ“
    â†’ Resume reading âœ…
```

---

### **Synchronization Tokens (Safe Points)**

These are tokens where parsing can safely restart:

```
COMMON SYNCHRONIZATION POINTS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Semicolons (;)                   â”‚
â”‚ â€¢ Closing braces (})               â”‚
â”‚ â€¢ Keywords (if, while, return)     â”‚
â”‚ â€¢ End of statement                 â”‚
â”‚ â€¢ Beginning of next declaration    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» **CODE EXAMPLE 1: Simple Panic Mode Parser**

### **Erroneous Code:**

```c
int main() {
    int x = 5      // âŒ Missing semicolon
    float y = 3.14;
    return 0;
}
```

---

### **Panic Mode Recovery Process:**

```
STEP-BY-STEP VISUALIZATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Parse normally
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ int main() {            â”‚ âœ…
â”‚   int x = 5             â”‚ Parsing...
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 2: Error detected
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ int x = 5 [float]       â”‚ âŒ Expected ';', found 'float'
â”‚           â”€â”€â”€â”€â”€         â”‚
â”‚           â””â”€ ERROR!     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 3: PANIC! Discard tokens
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Skip: float y = 3.14    â”‚ ğŸ—‘ï¸ Discarding...
â”‚       â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 4: Find synchronization point
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ float y = 3.14;         â”‚ ğŸ“ Found ';' (sync point)
â”‚                â”€        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STEP 5: Resume parsing
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   return 0;             â”‚ âœ… Continue parsing
â”‚ }                       â”‚ âœ… Success
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OUTPUT:
Line 2: Syntax error - Expected ';' after expression
Recovered at line 3
```

---

## ğŸ”§ **PSEUDOCODE: Panic Mode Algorithm**

```python
function parse_statement():
    try:
        match_token(TYPE)        # Expect type (int, float, etc.)
        match_token(IDENTIFIER)  # Expect variable name
        match_token(ASSIGN)      # Expect '='
        parse_expression()       # Parse right-hand side
        match_token(SEMICOLON)   # Expect ';'
    except SyntaxError as error:
        report_error(error)
        panic_mode_recovery()    # ğŸ”¥ PANIC MODE
        
function panic_mode_recovery():
    # Discard tokens until synchronization point
    while current_token NOT IN [SEMICOLON, RBRACE, KEYWORD]:
        discard_token()          # ğŸ—‘ï¸ Skip bad tokens
        advance()                # Move to next
    
    # Found sync point - resume parsing
    if current_token == SEMICOLON:
        advance()                # Move past ';'
```

---

## ğŸ’¡ **CODE EXAMPLE 2: Python Implementation**

```python
class Token:
    def __init__(self, type, value):
        self.type = type
        self.value = value

class PanicModeParser:
    def __init__(self, tokens):
        self.tokens = tokens
        self.pos = 0
        self.errors = []
        
        # Synchronization tokens (safe points)
        self.sync_tokens = {'SEMICOLON', 'RBRACE', 'IF', 'WHILE', 'RETURN'}
    
    def current_token(self):
        if self.pos < len(self.tokens):
            return self.tokens[self.pos]
        return Token('EOF', None)
    
    def advance(self):
        self.pos += 1
    
    def match(self, expected_type):
        """Check if current token matches expected type"""
        token = self.current_token()
        if token.type == expected_type:
            self.advance()
            return True
        else:
            # ERROR! Enter panic mode
            self.error(f"Expected {expected_type}, found {token.type}")
            self.panic_mode_recovery()
            return False
    
    def panic_mode_recovery(self):
        """ğŸ”¥ PANIC MODE: Skip until synchronization point"""
        print("âš ï¸  Entering PANIC MODE - discarding tokens...")
        
        discarded = []
        # Skip tokens until we find a sync point
        while self.current_token().type not in self.sync_tokens and \
              self.current_token().type != 'EOF':
            discarded.append(self.current_token().value)
            self.advance()
        
        print(f"ğŸ—‘ï¸  Discarded: {discarded}")
        print(f"ğŸ“ Synchronized at: {self.current_token().type}")
        
        # Move past sync token to continue
        if self.current_token().type == 'SEMICOLON':
            self.advance()
    
    def error(self, message):
        """Record error"""
        self.errors.append(f"Line {self.pos}: {message}")
    
    def parse_statement(self):
        """Parse: type identifier = expression;"""
        print(f"\nğŸ” Parsing statement at position {self.pos}")
        
        # Expect type keyword
        self.match('TYPE')
        
        # Expect identifier
        self.match('IDENTIFIER')
        
        # Expect '='
        self.match('ASSIGN')
        
        # Expect number/expression
        self.match('NUMBER')
        
        # Expect ';'
        self.match('SEMICOLON')
    
    def parse(self):
        """Parse multiple statements"""
        while self.current_token().type != 'EOF':
            self.parse_statement()
        
        # Report all errors
        print("\n" + "="*50)
        if self.errors:
            print(f"âŒ Found {len(self.errors)} error(s):")
            for error in self.errors:
                print(f"  â€¢ {error}")
        else:
            print("âœ… No errors found!")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# TEST CASE: Code with errors
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# Simulating: int x = 5  float y = 3.14;
#                     â†‘ Missing semicolon

tokens = [
    Token('TYPE', 'int'),
    Token('IDENTIFIER', 'x'),
    Token('ASSIGN', '='),
    Token('NUMBER', '5'),
    # Missing SEMICOLON here! âŒ
    Token('TYPE', 'float'),      # This will trigger panic mode
    Token('IDENTIFIER', 'y'),
    Token('ASSIGN', '='),
    Token('NUMBER', '3.14'),
    Token('SEMICOLON', ';'),
    Token('EOF', None)
]

parser = PanicModeParser(tokens)
parser.parse()
```

---

### **OUTPUT:**

```
ğŸ” Parsing statement at position 0
Line 4: Expected SEMICOLON, found TYPE
âš ï¸  Entering PANIC MODE - discarding tokens...
ğŸ—‘ï¸  Discarded: ['float', 'y', '=', '3.14']
ğŸ“ Synchronized at: SEMICOLON

ğŸ” Parsing statement at position 9
Line 9: Expected TYPE, found EOF

==================================================
âŒ Found 2 error(s):
  â€¢ Line 4: Expected SEMICOLON, found TYPE
  â€¢ Line 9: Expected TYPE, found EOF
```

**Explanation:**
1. Parser expected `;` after `5`, found `float` instead â†’ **ERROR**
2. **PANIC MODE** activated â†’ discarded `float y = 3.14`
3. Found `;` â†’ **synchronized** and continued
4. Hit EOF (end of file) â†’ stopped

---

## ğŸ¨ **VISUAL: Panic Mode Flow**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PANIC MODE FLOWCHART                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        START PARSING
             â”‚
             â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Match Token?â”‚
      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚         â”‚
       YES       NO
        â”‚         â”‚
        â–¼         â–¼
    CONTINUE  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ REPORT ERRORâ”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
              ğŸ”¥ PANIC MODE ğŸ”¥
                     â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
              â”‚ DISCARD     â”‚
              â”‚ TOKENS      â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ Sync Token? â”‚
              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
                â”‚         â”‚
               NO        YES
                â”‚         â”‚
                â”‚         â–¼
                â”‚    ğŸ“ FOUND!
                â”‚         â”‚
                â””â”€â”€â”€â”€â”    â”‚
                     â”‚    â–¼
                     â”‚ RESUME
                     â”‚ PARSING
                     â”‚    â”‚
                     â””â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š **CODE EXAMPLE 3: Multiple Errors**

### **Erroneous Code:**

```c
int main() {
    int x = 5          // âŒ Error 1: Missing ;
    float y = "hello"  // âŒ Error 2: Type mismatch + Missing ;
    int z = 10;        // âœ… Correct
    return 0;
}
```

### **Token Stream:**

```python
tokens = [
    # Statement 1: int x = 5 [MISSING ;]
    Token('TYPE', 'int'),
    Token('IDENTIFIER', 'x'),
    Token('ASSIGN', '='),
    Token('NUMBER', '5'),
    # âŒ Should have SEMICOLON here
    
    # Statement 2: float y = "hello" [MISSING ;]
    Token('TYPE', 'float'),
    Token('IDENTIFIER', 'y'),
    Token('ASSIGN', '='),
    Token('STRING', '"hello"'),
    # âŒ Should have SEMICOLON here
    
    # Statement 3: int z = 10; [CORRECT]
    Token('TYPE', 'int'),
    Token('IDENTIFIER', 'z'),
    Token('ASSIGN', '='),
    Token('NUMBER', '10'),
    Token('SEMICOLON', ';'),
    
    Token('RETURN', 'return'),
    Token('NUMBER', '0'),
    Token('SEMICOLON', ';'),
    Token('EOF', None)
]
```

### **Parser Output:**

```
ğŸ” Parsing statement at position 0
Line 4: Expected SEMICOLON, found TYPE
âš ï¸  Entering PANIC MODE - discarding tokens...
ğŸ—‘ï¸  Discarded: ['float', 'y', '=', '"hello"']
ğŸ“ Synchronized at: TYPE (int z)

ğŸ” Parsing statement at position 9
âœ… Parsed successfully: int z = 10;

ğŸ” Parsing statement at position 14
Line 14: Expected TYPE, found RETURN

==================================================
âŒ Found 2 error(s):
  â€¢ Line 4: Expected SEMICOLON, found TYPE
  â€¢ Line 14: Expected TYPE, found RETURN

âœ… Successfully parsed 1 statement
âš ï¸  Skipped 1 erroneous statement
```

---

## ğŸ§© **CODE EXAMPLE 4: C-Style Implementation**

```c
#include <stdio.h>
#include <string.h>

typedef enum {
    TYPE, IDENTIFIER, ASSIGN, NUMBER, SEMICOLON, 
    LBRACE, RBRACE, IF, WHILE, RETURN, END_OF_FILE
} TokenType;

typedef struct {
    TokenType type;
    char value[50];
} Token;

Token tokens[100];
int pos = 0;
int token_count = 0;

// Synchronization tokens
int is_sync_token(TokenType type) {
    return (type == SEMICOLON || type == RBRACE || 
            type == IF || type == WHILE || type == RETURN);
}

void panic_mode_recovery() {
    printf("\nğŸ”¥ PANIC MODE ACTIVATED ğŸ”¥\n");
    printf("ğŸ—‘ï¸  Discarding tokens: ");
    
    // Skip until synchronization point
    while (!is_sync_token(tokens[pos].type) && 
           tokens[pos].type != END_OF_FILE) {
        printf("%s ", tokens[pos].value);
        pos++;
    }
    
    printf("\nğŸ“ Synchronized at: %s\n", tokens[pos].value);
    
    // Move past sync token
    if (tokens[pos].type == SEMICOLON) {
        pos++;
    }
}

int match(TokenType expected) {
    if (tokens[pos].type == expected) {
        pos++;
        return 1;  // Success
    } else {
        printf("âŒ Error at position %d: Expected %d, found %d\n", 
               pos, expected, tokens[pos].type);
        panic_mode_recovery();
        return 0;  // Failed
    }
}

void parse_statement() {
    printf("\nğŸ” Parsing statement at position %d\n", pos);
    
    match(TYPE);
    match(IDENTIFIER);
    match(ASSIGN);
    match(NUMBER);
    match(SEMICOLON);
}

int main() {
    // Setup tokens: int x = 5 [missing ;] float y = 3;
    tokens[0] = (Token){TYPE, "int"};
    tokens[1] = (Token){IDENTIFIER, "x"};
    tokens[2] = (Token){ASSIGN, "="};
    tokens[3] = (Token){NUMBER, "5"};
    // Missing semicolon!
    tokens[4] = (Token){TYPE, "float"};
    tokens[5] = (Token){IDENTIFIER, "y"};
    tokens[6] = (Token){ASSIGN, "="};
    tokens[7] = (Token){NUMBER, "3"};
    tokens[8] = (Token){SEMICOLON, ";"};
    tokens[9] = (Token){END_OF_FILE, ""};
    
    token_count = 10;
    
    // Parse
    while (tokens[pos].type != END_OF_FILE) {
        parse_statement();
    }
    
    printf("\nâœ… Parsing complete\n");
    return 0;
}
```

---

## ğŸ¯ **ADVANTAGES vs DISADVANTAGES**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              PANIC MODE RECOVERY                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… ADVANTAGES        â”‚ âŒ DISADVANTAGES            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ Simple to code     â”‚ â€¢ May skip valid code        â”‚
â”‚ â€¢ Fast execution     â”‚ â€¢ Cascading errors possible  â”‚
â”‚ â€¢ Finds multiple     â”‚ â€¢ Not always accurate        â”‚
â”‚   errors             â”‚ â€¢ May miss related errors    â”‚
â”‚ â€¢ Used in real       â”‚ â€¢ Recovery not guaranteed    â”‚
â”‚   compilers (GCC)    â”‚                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ **SUMMARY: Key Points**

```
PANIC MODE IN 3 STEPS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1ï¸âƒ£ DETECT: Find syntax error          â”‚
â”‚ 2ï¸âƒ£ DISCARD: Skip tokens until sync    â”‚
â”‚ 3ï¸âƒ£ RESUME: Continue parsing           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SYNCHRONIZATION POINTS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Semicolons (;)                       â”‚
â”‚ â€¢ Statement keywords (if, while, for)  â”‚
â”‚ â€¢ Block delimiters ({ })               â”‚
â”‚ â€¢ End of declarations                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§  **MEMORY TRICK: "DRS"**

```
D = DETECT error
R = RECOVER by discarding
S = SYNCHRONIZE at safe point
```

---

**ğŸ“ You now understand Panic Mode Recovery! It's used in GCC, Clang, and most production compilers! ğŸš€**
