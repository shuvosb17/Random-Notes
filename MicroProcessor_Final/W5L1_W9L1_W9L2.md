# ğŸ–¥ï¸ **MICROPROCESSOR â€” Complete Visual Guide (FLAGS, Logic, Shift & Rotate)**

---

## ğŸ¯ **THE BIG PICTURE: What We're Learning**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         8086 MICROPROCESSOR ESSENTIALS              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚               â”‚               â”‚
   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
   â”‚  FLAGS  â”‚     â”‚  LOGIC  â”‚    â”‚  SHIFT  â”‚
   â”‚(Status) â”‚     â”‚  INSTR  â”‚    â”‚ ROTATE  â”‚
   â”‚  Report â”‚     â”‚  Masks  â”‚    â”‚  Bits   â”‚
   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”‚               â”‚               â”‚
        â–¼               â–¼               â–¼
   What just      Change bits    Move bits
   happened?      selectively    around
```

---

## ğŸ“– **COMPLETE ROADMAP**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            MICROPROCESSOR JOURNEY                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PART 1: FLAGS REGISTER
â”œâ”€ What are flags?
â”œâ”€ Individual flag meanings
â”œâ”€ CF vs OF (the big confusion!)
â””â”€ Flag update examples

PART 2: LOGIC INSTRUCTIONS
â”œâ”€ AND / OR / XOR / NOT
â”œâ”€ Truth tables (bit-level)
â”œâ”€ Masking techniques
â”‚  â”œâ”€ Clear bits (AND)
â”‚  â”œâ”€ Set bits (OR)
â”‚  â””â”€ Toggle bits (XOR)
â””â”€ TEST instruction

PART 3: SHIFT & ROTATE
â”œâ”€ Logical shifts (SHL/SHR)
â”œâ”€ Arithmetic shift (SAR)
â”œâ”€ Pure rotates (ROL/ROR)
â””â”€ Rotate through carry (RCL/RCR)

PART 4: PRACTICE & MASTERY
â”œâ”€ Worked examples
â”œâ”€ Memory aids
â””â”€ Cheat sheets
```

---

# ğŸš© **PART 1: FLAGS REGISTER (The CPU's Report Card)**

## **What Are Flags?**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   FLAGS = 1-BIT INDICATORS OF CPU STATUS         â”‚
â”‚                                                  â”‚
â”‚   After each operation, CPU updates flags to     â”‚
â”‚   tell you what happened                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ANALOGY:
Think of flags as dashboard warning lights! ğŸš—

After driving (operation):
âœ… Low fuel warning (Carry Flag)
âœ… Check engine (Overflow Flag)
âœ… Oil light (Zero Flag)
etc.
```

---

## **FLAGS Register Layout (8086)**

```
15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”
â”‚  â”‚  â”‚  â”‚  â”‚OFâ”‚DFâ”‚IFâ”‚TFâ”‚SFâ”‚ZFâ”‚  â”‚AFâ”‚  â”‚PFâ”‚  â”‚CFâ”‚
â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜
 â†‘           â†‘              â†‘  â†‘     â†‘     â†‘     â†‘
 |           |              |  |     |     |     |
 Reserved    Overflow      Sign Zero Aux  Parity Carry
                           Flag Flag  Flag  Flag  Flag

WE FOCUS ON: CF, PF, AF, ZF, SF, OF
(These change after ALU operations)
```

---

## **Individual Flag Meanings**

### **1. CF (Carry Flag) â€” Bit 0**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CF = UNSIGNED OVERFLOW INDICATOR       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHEN SET (CF = 1):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Addition: Carry out of MSB
â€¢ Subtraction: Borrow into MSB
â€¢ Shift/Rotate: Last bit shifted out

VISUAL (8-bit addition):
        1111 1111  (255)
      + 0000 0001  (+1)
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (1) 0000 0000  (overflow!)
     â†‘
     â””â”€ This carry â†’ CF = 1

THINK: "Did result exceed container?"
```

---

### **2. PF (Parity Flag) â€” Bit 2**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PF = EVEN PARITY OF LOW BYTE           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHEN SET (PF = 1):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Even number of 1-bits in LOW BYTE (AL)

EXAMPLE:
Result AL = 0110 0110
Count 1s: 4 ones â†’ EVEN â†’ PF = 1

Result AL = 0110 0111
Count 1s: 5 ones â†’ ODD â†’ PF = 0

Visual Counter:
0110 0110
 â†‘â†‘  â†‘â†‘
 1234 ones â†’ Even â†’ PF = 1

USAGE: Error detection in data transmission
```

---

### **3. AF (Auxiliary Carry) â€” Bit 4**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   AF = CARRY BETWEEN NIBBLES             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHEN SET (AF = 1):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Carry/borrow from bit 3 to bit 4

VISUAL:
  Bit:  7 6 5 4 | 3 2 1 0
        â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€
  High nibbleâ”‚Low nibble
             â†‘
       Carry here â†’ AF = 1

EXAMPLE:
    0000 1111  (15)
  + 0000 0001  (+1)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    0001 0000  (16)
         â†‘
    Carry from bit 3â†’4 â†’ AF = 1

USAGE: BCD (Binary Coded Decimal) arithmetic
```

---

### **4. ZF (Zero Flag) â€” Bit 6**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ZF = RESULT IS ZERO                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHEN SET (ZF = 1):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Result of operation = 0

EXAMPLES:

Example 1:
MOV AX, 5
SUB AX, 5  â†’ AX = 0 â†’ ZF = 1 âœ…

Example 2:
MOV BX, 10
SUB BX, 5  â†’ BX = 5 â†’ ZF = 0 âŒ

VISUAL:
Result: 0000 0000 0000 0000
        All zeros! â†’ ZF = 1

USAGE: Conditional jumps (JZ, JNZ)
```

---

### **5. SF (Sign Flag) â€” Bit 7**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SF = SIGN BIT OF RESULT (MSB)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHEN SET (SF = 1):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MSB = 1 (negative if signed interpretation)

VISUAL (16-bit):
Result: 1010 0101 0011 1100
        â†‘
    MSB=1 â†’ SF = 1 (negative signed)

EXAMPLES:

Positive result:
0111 1111 1111 1111 â†’ MSB=0 â†’ SF = 0

Negative result:
1000 0000 0000 0001 â†’ MSB=1 â†’ SF = 1

THINK: "Is the number negative (signed)?"
```

---

### **6. OF (Overflow Flag) â€” Bit 11**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   OF = SIGNED OVERFLOW INDICATOR         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHEN SET (OF = 1):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Signed result doesn't fit in register

DETECTION LOGIC:
OF = (Carry into MSB) XOR (Carry out of MSB)

VISUAL RULE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Positive + Positive = Negative â†’ OF = 1 âŒ
Negative + Negative = Positive â†’ OF = 1 âŒ
Positive + Negative = Anything â†’ OF = 0 âœ…

THINK: "Did signs flip unexpectedly?"
```

---

## ğŸ”¥ **CF vs OF: THE BIG CONFUSION RESOLVED!**

### **Visual Comparison:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CF vs OF                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Feature      â”‚ CF (Carry)      â”‚ OF (Overflow)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Applies to   â”‚ UNSIGNED        â”‚ SIGNED            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Checks       â”‚ Physical carry  â”‚ Sign correctness  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ When set     â”‚ Result > max    â”‚ Sign flipped      â”‚
â”‚              â”‚ unsigned value  â”‚ incorrectly       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Example      â”‚ 255 + 1 = 256   â”‚ 127 + 1 = -128    â”‚
â”‚ (8-bit)      â”‚ â†’ CF = 1        â”‚ â†’ OF = 1          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Example 1: Unsigned Overflow (CF)**

```
PROBLEM: 8-bit addition
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    1111 1111  (255 unsigned)
  + 0000 0001  (+1)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(1) 0000 0000  (0 stored)
 â†‘
Carry out â†’ CF = 1 âœ…

AS UNSIGNED:
255 + 1 = 256 â†’ TOO BIG for 8-bit!
â†’ CF = 1 (unsigned overflow)

AS SIGNED:
-1 + 1 = 0 â†’ CORRECT!
â†’ OF = 0 (no signed overflow)

RESULT FLAGS:
CF = 1 âœ… (unsigned problem)
OF = 0 âœ… (signed OK)
ZF = 1 âœ… (result is 0)
SF = 0 âœ… (MSB = 0)
```

---

### **Example 2: Signed Overflow (OF)**

```
PROBLEM: 8-bit addition
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    0111 1111  (+127 signed)
  + 0000 0001  (+1)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    1000 0000  (-128 stored!)
              
NO carry out â†’ CF = 0 âœ…

AS UNSIGNED:
127 + 1 = 128 â†’ FITS in 8-bit!
â†’ CF = 0 (no unsigned overflow)

AS SIGNED:
+127 + 1 = +128 â†’ BUT result shows -128!
Sign FLIPPED incorrectly!
â†’ OF = 1 (signed overflow)

RESULT FLAGS:
CF = 0 âœ… (unsigned OK)
OF = 1 âœ… (signed problem)
SF = 1 âœ… (MSB = 1, looks negative)
ZF = 0 âœ… (result â‰  0)
```

---

### **Example 3: Both Set (FFFFh + 0001h in 16-bit)**

```
PROBLEM: 16-bit addition
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    1111 1111 1111 1111  (FFFFh)
  + 0000 0000 0000 0001  (0001h)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(1) 0000 0000 0000 0000  (0000h)
 â†‘
Carry out

AS UNSIGNED:
65535 + 1 = 65536 â†’ overflow!
â†’ CF = 1 âœ…

AS SIGNED:
-1 + 1 = 0 â†’ CORRECT!
â†’ OF = 0 âœ…

RESULT FLAGS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CF = 1 (unsigned)  â”‚
â”‚ OF = 0 (signed OK) â”‚
â”‚ ZF = 1 (zero)      â”‚
â”‚ SF = 0 (positive)  â”‚
â”‚ PF = 1 (even)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### **Decision Tree: Which Flag to Check?**

```
        After arithmetic operation
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                       â”‚
    Treating as            Treating as
    UNSIGNED?              SIGNED?
        â”‚                       â”‚
        â–¼                       â–¼
    Check CF              Check OF
        â”‚                       â”‚
    â”Œâ”€â”€â”€â”´â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
    â”‚       â”‚             â”‚           â”‚
   CF=1    CF=0          OF=1        OF=0
    â”‚       â”‚             â”‚           â”‚
    â–¼       â–¼             â–¼           â–¼
 Overflow  OK          Overflow      OK
```

---

## ğŸ“Š **How Operations Update Flags**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        INSTRUCTION FLAG EFFECTS                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Instruction  â”‚ Flags Affected                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ADD/SUB      â”‚ CF, PF, AF, ZF, SF, OF (ALL)        â”‚
â”‚ INC/DEC      â”‚ PF, AF, ZF, SF, OF (NOT CF!)        â”‚
â”‚ MUL/DIV      â”‚ CF, OF (others undefined)           â”‚
â”‚ AND/OR/XOR   â”‚ CF=0, OF=0, ZF, SF, PF              â”‚
â”‚ NOT          â”‚ NONE                                â”‚
â”‚ MOV/XCHG     â”‚ NONE                                â”‚
â”‚ SHL/SHR      â”‚ CF, PF, ZF, SF (OF for 1-bit)       â”‚
â”‚ ROL/ROR      â”‚ CF (OF for 1-bit shift)             â”‚
â”‚ CMP          â”‚ Same as SUB (CF, PF, AF, ZF, SF, OF)â”‚
â”‚ TEST         â”‚ Same as AND (CF=0, OF=0, ZF, SF, PF)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ **Complete Flag Update Example**

```
PROGRAM TRACE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MOV AX, FFFFh    ; AX = 1111 1111 1111 1111
MOV BX, 0001h    ; BX = 0000 0000 0000 0001
ADD AX, BX       ; AX = ?

STEP-BY-STEP:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Initial:
AX = 1111 1111 1111 1111 (FFFFh)
BX = 0000 0000 0000 0001 (0001h)

Addition:
        1111 1111 1111 1111
      + 0000 0000 0000 0001
      â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    (1) 0000 0000 0000 0000
     â†‘
  Carry out!

Result: AX = 0000h

FLAGS UPDATE:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Flag â”‚Valueâ”‚ Reason                       â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CF  â”‚  1  â”‚ Carry out of MSB             â”‚
â”‚ PF  â”‚  1  â”‚ AL=00h â†’ 0 ones (even)       â”‚
â”‚ AF  â”‚  1  â”‚ Carry from bit 3â†’4           â”‚
â”‚ ZF  â”‚  1  â”‚ Result = 0                   â”‚
â”‚ SF  â”‚  0  â”‚ MSB = 0                      â”‚
â”‚ OF  â”‚  0  â”‚ Signed: -1+1=0 (correct)     â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Visual Summary:
AX: 0000 0000 0000 0000
    â†‘                 â†‘
   MSB=0             All zeros
   SF=0              ZF=1
```

---

# âš¡ **PART 2: LOGIC INSTRUCTIONS (Bit Manipulation)**

## **The Four Logic Gates**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         TRUTH TABLES (Single Bit)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

 A  B â”‚ AND  OR  XOR  NOT A
â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 0  0 â”‚  0   0    0     1
 0  1 â”‚  0   1    1     1
 1  0 â”‚  0   1    1     0
 1  1 â”‚  1   1    0     0

APPLY TO EACH BIT POSITION!
```

---

## **Visual Logic Operations (8-bit)**

### **AND Operation:**

```
EXAMPLE: AL = 1010 1100
         BL = 1111 0000
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         AL = 1010 0000  (AND result)

BIT-BY-BIT:
Position:  7 6 5 4 3 2 1 0
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AL:        1 0 1 0 1 1 0 0
BL:        1 1 1 1 0 0 0 0
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AND:       1 0 1 0 0 0 0 0
           â†‘       â†‘ â†‘ â†‘ â†‘
        Both 1  Any 0â†’result 0

RULE: Result bit = 1 ONLY if BOTH are 1
```

---

### **OR Operation:**

```
EXAMPLE: AL = 1010 1100
         BL = 0000 1111
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         AL = 1010 1111  (OR result)

BIT-BY-BIT:
Position:  7 6 5 4 3 2 1 0
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AL:        1 0 1 0 1 1 0 0
BL:        0 0 0 0 1 1 1 1
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OR:        1 0 1 0 1 1 1 1
           â†‘       â†‘ â†‘ â†‘ â†‘
        Any 1 â†’ result 1

RULE: Result bit = 1 if EITHER is 1
```

---

### **XOR Operation:**

```
EXAMPLE: AL = 1010 1100
         BL = 1111 0000
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         AL = 0101 1100  (XOR result)

BIT-BY-BIT:
Position:  7 6 5 4 3 2 1 0
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AL:        1 0 1 0 1 1 0 0
BL:        1 1 1 1 0 0 0 0
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
XOR:       0 1 0 1 1 1 0 0
           â†‘ â†‘ â†‘ â†‘
       Sameâ†’0 Diffâ†’1

RULE: Result bit = 1 if bits DIFFER
```

---

### **NOT Operation:**

```
EXAMPLE: AL = 1010 1100
         NOT AL
         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
         AL = 0101 0011  (NOT result)

BIT-BY-BIT:
Position:  7 6 5 4 3 2 1 0
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
AL:        1 0 1 0 1 1 0 0
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
NOT:       0 1 0 1 0 0 1 1
           â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘ â†‘
         Every bit flipped

RULE: Each bit inverted (1â†’0, 0â†’1)
```

---

## ğŸ­ **MASKING TECHNIQUES**

### **What Is a Mask?**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   MASK = Pattern to selectively change bits     â”‚
â”‚                                                  â”‚
â”‚   Use second operand as "template"              â”‚
â”‚   to modify first operand                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CONCEPT:
Original Data + Mask + Operation = Modified Data
                 â†“         â†“
              Template  AND/OR/XOR
```

---

### **1. CLEAR BITS (Set to 0) â€” Use AND**

```
RULE:
â”€â”€â”€â”€â”€
AND with 0 â†’ forces bit to 0
AND with 1 â†’ preserves bit

EXAMPLE: Clear bits 7,4,0 of AL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Original AL: 1010 1101
Want clear:  7   4   0
             â†“   â†“   â†“
Mask:        0110 1110  (0s at positions to clear)

Operation:
    1010 1101  (AL)
AND 0110 1110  (Mask)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    0010 1100  (Result)
    â†‘   â†‘   â†‘
  Cleared positions

CODE:
AND AL, 01101110b  ; or AND AL, 6Eh
```

---

### **Visual Mask Design (Clear):**

```
WANT TO CLEAR: Bits 7, 4, 0

STEP 1: Start with all 1s
11111111

STEP 2: Put 0 where you want to clear
01101110
â†‘   â†‘   â†‘
Cleared positions

STEP 3: AND with data
Original: 1010 1101
Mask:     0110 1110
Result:   0010 1100 âœ…

POSITIONS CLEARED! âœ…
Others preserved! âœ…
```

---

### **2. SET BITS (Force to 1) â€” Use OR**

```
RULE:
â”€â”€â”€â”€â”€
OR with 1 â†’ forces bit to 1
OR with 0 â†’ preserves bit

EXAMPLE: Set bits 7,0 of AL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Original AL: 0010 1100
Want set:    7       0
             â†“       â†“
Mask:        1000 0001  (1s at positions to set)

Operation:
    0010 1100  (AL)
OR  1000 0001  (Mask)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    1010 1101  (Result)
    â†‘       â†‘
  Set positions

CODE:
OR AL, 10000001b  ; or OR AL, 81h
```

---

### **Visual Mask Design (Set):**

```
WANT TO SET: Bits 7, 0

STEP 1: Start with all 0s
00000000

STEP 2: Put 1 where you want to set
10000001
â†‘       â†‘
Set positions

STEP 3: OR with data
Original: 0010 1100
Mask:     1000 0001
Result:   1010 1101 âœ…

POSITIONS SET! âœ…
Others preserved! âœ…
```

---

### **3. TOGGLE BITS (Flip) â€” Use XOR**

```
RULE:
â”€â”€â”€â”€â”€
XOR with 1 â†’ flips bit
XOR with 0 â†’ preserves bit

EXAMPLE: Toggle bits 7,4,0 of AL
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Original AL: 1010 1101
Want toggle: 7   4   0
             â†“   â†“   â†“
Mask:        1001 0001  (1s at positions to toggle)

Operation:
    1010 1101  (AL)
XOR 1001 0001  (Mask)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    0011 1100  (Result)
    â†‘   â†‘   â†‘
  Toggled positions

CODE:
XOR AL, 10010001b  ; or XOR AL, 91h
```

---

### **Visual Toggle Example:**

```
ORIGINAL: 1010 1101
MASK:     1001 0001
          â†“  â†“    â†“
RESULT:   0011 1100

BIT-BY-BIT TOGGLE:
Position 7: 1 XOR 1 = 0 (flipped!)
Position 6: 0 XOR 0 = 0 (preserved)
Position 5: 1 XOR 0 = 1 (preserved)
Position 4: 0 XOR 1 = 1 (flipped!)
Position 3: 1 XOR 0 = 1 (preserved)
Position 2: 1 XOR 0 = 1 (preserved)
Position 1: 0 XOR 0 = 0 (preserved)
Position 0: 1 XOR 1 = 0 (flipped!)
```

---

## ğŸ¯ **MASKING SUMMARY FLOW**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          MASKING DECISION TREE                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    What do you want to do?
              â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚         â”‚         â”‚
    â–¼         â–¼         â–¼
  CLEAR      SET     TOGGLE
   BITS      BITS     BITS
    â”‚         â”‚         â”‚
    â–¼         â–¼         â–¼
   AND       OR       XOR
    â”‚         â”‚         â”‚
  Mask:     Mask:    Mask:
  0=clear   1=set    1=flip
  1=keep    0=keep   0=keep
```

---

## ğŸ” **TEST Instruction (Non-Destructive AND)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TEST = AND without storing result              â”‚
â”‚   (Only updates flags)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SYNTAX:
TEST destination, source

BEHAVIOR:
1. Performs AND operation
2. Updates flags (ZF, SF, PF)
3. Sets CF=0, OF=0
4. Does NOT change operands!

USE CASE: Check if bits are set
```

---

### **TEST Examples:**

```
EXAMPLE 1: Check if bit 0 is set (odd/even)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MOV AL, 1010 0111  ; Some number
TEST AL, 1         ; Check bit 0
JZ even            ; Jump if ZF=1 (bit 0 was 0)
; else it's odd

LOGIC:
  1010 0111
& 0000 0001
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  0000 0001  (nonzero) â†’ ZF = 0 â†’ odd âœ…


EXAMPLE 2: Check if number is zero
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

TEST AX, AX        ; Test AX against itself
JZ is_zero         ; Jump if ZF=1

LOGIC:
If AX = 0:
  0000 & 0000 = 0000 â†’ ZF = 1 âœ…
If AX â‰  0:
  Some 1s remain â†’ ZF = 0 âœ…


EXAMPLE 3: Check multiple bits
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

MOV BL, 1010 1100
TEST BL, 1100 0000  ; Check bits 7,6
JZ not_set          ; Jump if both are 0

LOGIC:
  1010 1100
& 1100 0000
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  1000 0000  (nonzero) â†’ ZF = 0
Bits 7,6 not both zero!
```

---

## ğŸ’¡ **Useful Logic Tricks**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         CLEVER LOGIC OPERATIONS                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TRICK 1: Clear register (fastest)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
XOR AX, AX     ; AX = 0
               ; Faster than MOV AX, 0
               ; Fewer bytes!

Why it works:
Any number XOR itself = 0
1010 XOR 1010 = 0000 âœ…


TRICK 2: Toggle sign bit
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
XOR AX, 8000h  ; Flip bit 15
               ; Positive â†” Negative

Example:
0111 1111 1111 1111  (+32767)
XOR with 1000 0000 0000 0000
= 1111 1111 1111 1111  (-1)


TRICK 3: Isolate lowest set bit
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MOV BX, AX
NEG BX         ; Two's complement
AND AX, BX     ; Isolate lowest 1

Example:
AX = 1010 1100
Isolates â†’ 0000 0100 (bit 2)


TRICK 4: Check power of 2
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
; Number is power of 2 if only 1 bit set
MOV BX, AX
DEC BX
AND AX, BX
JZ is_power_of_2

Why:
Power of 2: 0001 0000
Minus 1:    0000 1111
AND:        0000 0000 â†’ ZF=1 âœ…
```

---

# ğŸ”„ **PART 3: SHIFT & ROTATE INSTRUCTIONS**

## **Shift vs Rotate Overview**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SHIFT vs ROTATE                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                  â”‚
â”‚ SHIFT:                                           â”‚
â”‚ â€¢ Bits move left/right                           â”‚
â”‚ â€¢ New bits filled with 0 (or sign bit)           â”‚
â”‚ â€¢ Lost bits go to CF                             â”‚
â”‚ â€¢ Data can be LOST                               â”‚
â”‚                                                  â”‚
â”‚ ROTATE:                                          â”‚
â”‚ â€¢ Bits move circularly                           â”‚
â”‚ â€¢ No bits lost (cycle around)                    â”‚
â”‚ â€¢ CF may participate                             â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ **SHIFT INSTRUCTIONS**

### **1. SHL (Shift Left) / SAL (Same as SHL)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SHL = Shift Logical Left                       â”‚
â”‚   SAL = Shift Arithmetic Left (identical to SHL) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All bits shift left
â€¢ MSB â†’ CF (lost from register)
â€¢ LSB â† 0 (filled with zero)
â€¢ Effectively multiplies by 2

VISUAL (8-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE:
CF  b7 b6 b5 b4 b3 b2 b1 b0
 ?   1  0  1  0  1  1  0  0

AFTER SHL 1:
CF  b7 b6 b5 b4 b3 b2 b1 b0
 1   0  1  0  1  1  0  0  0
 â†‘   â†‘                     â†‘
Old  Old b6               New 0
MSB  becomes               filled
     new b7

SYNTAX:
SHL destination, count
SHL AL, 1          ; Shift left 1 bit
SHL BX, CL         ; Shift left CL times
```

---

### **SHL Detailed Example:**

```
EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€
MOV AL, 1010 1100  ; AL = ACh
SHL AL, 1          ; Shift left 1

STEP-BY-STEP:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Initial:
  7 6 5 4 3 2 1 0
  1 0 1 0 1 1 0 0  (AL)

After SHL 1:
  7 6 5 4 3 2 1 0
  0 1 0 1 1 0 0 0  (New AL)
  â†‘               â†‘
  Old b6       New 0

CF = 1 (old MSB)

DECIMAL VIEW:
172 Ã— 2 = 344... but AL only holds 8 bits
Stored: 344 mod 256 = 88

FLAGS:
CF = 1 (MSB shifted out)
OF = 1 (sign changed: was neg, now pos)
```

---

### **2. SHR (Shift Right Logical)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SHR = Shift Logical Right                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All bits shift right
â€¢ LSB â†’ CF (lost from register)
â€¢ MSB â† 0 (filled with zero)
â€¢ Effectively divides by 2 (unsigned)

VISUAL (8-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE:
b7 b6 b5 b4 b3 b2 b1 b0  CF
 1  0  1  0  1  1  0  0   ?

AFTER SHR 1:
b7 b6 b5 b4 b3 b2 b1 b0  CF
 0  1  0  1  0  1  1  0   0
 â†‘                     â†‘  â†‘
New 0                Old Old
filled               b0  LSB

SYNTAX:
SHR destination, count
```

---

### **SHR Detailed Example:**

```
EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€
MOV AL, 1010 1100  ; AL = ACh (172)
SHR AL, 1          ; Shift right 1

STEP-BY-STEP:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Initial:
  7 6 5 4 3 2 1 0
  1 0 1 0 1 1 0 0  (AL)

After SHR 1:
  7 6 5 4 3 2 1 0
  0 1 0 1 0 1 1 0  (New AL)
  â†‘               â†‘
New 0          Old b1
filled

CF = 0 (old LSB)

DECIMAL VIEW:
172 Ã· 2 = 86 âœ…

FLAGS:
CF = 0 (LSB shifted out was 0)
OF = 1 (MSB changed from 1 to 0)
```

---

### **3. SAR (Shift Arithmetic Right)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   SAR = Shift Arithmetic Right                   â”‚
â”‚   (Preserves sign bit)                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All bits shift right
â€¢ LSB â†’ CF (lost)
â€¢ MSB â† OLD MSB (sign bit preserved!)
â€¢ Correctly divides SIGNED numbers by 2

VISUAL (8-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE (negative number):
b7 b6 b5 b4 b3 b2 b1 b0  CF
 1  0  1  0  1  1  0  0   ?
 â†‘
Sign bit

AFTER SAR 1:
b7 b6 b5 b4 b3 b2 b1 b0  CF
 1  1  0  1  0  1  1  0   0
 â†‘â†‘                    â†‘  â†‘
 Sign                 Old Old
 preserved           b0  LSB
```

---

### **SAR vs SHR Comparison:**

```
EXAMPLE NUMBER: 1010 1100 (-84 signed, 172 unsigned)

SHR (Logical):
1010 1100 â†’ 0101 0110
            â†‘
         New 0 (breaks sign!)

Result: 86 (unsigned OK)
        +86 (signed WRONG! Was -84)


SAR (Arithmetic):
1010 1100 â†’ 1101 0110
            â†‘
         Sign preserved!

Result: 214 unsigned
        -42 signed âœ… (Correct: -84Ã·2=-42)


USE SAR FOR SIGNED DIVISION! âœ…
USE SHR FOR UNSIGNED DIVISION! âœ…
```

---

## ğŸ”„ **ROTATE INSTRUCTIONS**

### **1. ROL (Rotate Left)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ROL = Rotate Left (circular)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All bits shift left circularly
â€¢ MSB â†’ LSB (wraps around!)
â€¢ MSB â†’ CF (also copied to CF)
â€¢ NO BITS LOST!

VISUAL (8-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                              â”‚
CF  â–¼7 b6 b5 b4 b3 b2 b1 b0        â”‚
 ?   1  0  1  0  1  1  0  0        â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AFTER ROL 1:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                              â”‚
CF  â–¼7 b6 b5 b4 b3 b2 b1 b0        â”‚
 1   0  1  0  1  1  0  0  1â†â”€â”€â”€â”€â”€â”€â”€â”˜
 â†‘                        â†‘
 Copy                  Wrapped
 of MSB                 around
```

---

### **ROL Detailed Example:**

```
EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€
MOV BL, 1011 0111  ; BL = B7h
ROL BL, 1          ; Rotate left 1

STEP-BY-STEP:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Initial:
  7 6 5 4 3 2 1 0
  1 0 1 1 0 1 1 1  (BL)
  â†‘
  This wraps around

After ROL 1:
  7 6 5 4 3 2 1 0
  0 1 1 0 1 1 1 1  (New BL)
                â†‘
              Old MSB
              became LSB

CF = 1 (copy of old MSB)

NOTHING LOST! All bits preserved! âœ…
```

---

### **2. ROR (Rotate Right)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ROR = Rotate Right (circular)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ All bits shift right circularly
â€¢ LSB â†’ MSB (wraps around!)
â€¢ LSB â†’ CF (also copied)
â€¢ NO BITS LOST!

VISUAL (8-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE:
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚                              â”‚
 â”‚  b7 b6 b5 b4 b3 b2 b1 b0  CF
 â”‚   1  0  1  0  1  1  0  0  ?
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
                            â”‚

AFTER ROR 1:
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”
 â”‚                          â”‚   â”‚
 â”‚  b7 b6 b5 b4 b3 b2 b1 b0 CF  â”‚
 â””â†’  0  1  0  1  0  1  1  0  0â†â”€â”˜
     â†‘                       â†‘
   Old LSB                Copy
   became MSB            of LSB
```

---

### **3. RCL (Rotate Through Carry Left)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   RCL = Rotate Left THROUGH Carry Flag           â”‚
â”‚   (CF participates as 9th bit!)                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ CF shifts into LSB
â€¢ MSB shifts into CF
â€¢ Effectively rotating 9 bits (8 data + CF)

VISUAL (8-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE:
CF  b7 b6 b5 b4 b3 b2 b1 b0
 0   1  0  0  0  1  0  0  0
 â”‚   â†‘
 â”‚   Will go to CF
 â””â”€â”€ Will go to b0

AFTER RCL 1:
CF  b7 b6 b5 b4 b3 b2 b1 b0
 1   0  0  0  1  0  0  0  0
 â†‘                       â†‘
Old b7                 Old CF
```

---

### **RCL Step-by-Step Example:**

```
EXAMPLE:
â”€â”€â”€â”€â”€â”€â”€â”€
CLC                ; Clear CF (CF = 0)
MOV BL, 1000 1000  ; BL = 88h
RCL BL, 1          ; Rotate left through carry
RCL BL, 1          ; Again
RCL BL, 1          ; Again

TRACE:
â”€â”€â”€â”€â”€â”€

Initial state:
CF = 0
BL = 1000 1000

After 1st RCL:
  1000 1000 with CF=0
  â†“
  0001 0000 with CF=1
  â†‘         â†‘
  Old b7    Old CF
  to CF     to b0

After 2nd RCL:
  0001 0000 with CF=1
  â†“
  0010 0001 with CF=0
         â†‘
      Old CF

After 3rd RCL:
  0010 0001 with CF=0
  â†“
  0100 0010 with CF=0

FINAL:
CF = 0
BL = 0100 0010 (42h)
```

---

### **4. RCR (Rotate Through Carry Right)**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   RCR = Rotate Right THROUGH Carry Flag          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OPERATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ CF shifts into MSB
â€¢ LSB shifts into CF
â€¢ 9-bit rotation (8 data + CF)

VISUAL (8-bit):
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

BEFORE:
b7 b6 b5 b4 b3 b2 b1 b0  CF
 1  0  0  0  1  0  0  0   0
                     â†‘   â†‘
                     â”‚   â”‚
              Will go to CF
                         Will go to b7

AFTER RCR 1:
b7 b6 b5 b4 b3 b2 b1 b0  CF
 0  1  0  0  0  1  0  0   0
 â†‘                       â†‘
Old CF                 Old b0
```

---

## ğŸ“Š **SHIFT & ROTATE COMPARISON TABLE**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        COMPLETE SHIFT/ROTATE REFERENCE             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Instr    â”‚ Direction   â”‚ Fill Bit     â”‚ Lost Bit   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SHL/SAL  â”‚ Left        â”‚ 0 â†’ LSB      â”‚ MSB â†’ CF   â”‚
â”‚ SHR      â”‚ Right       â”‚ 0 â†’ MSB      â”‚ LSB â†’ CF   â”‚
â”‚ SAR      â”‚ Right       â”‚ Sign â†’ MSB   â”‚ LSB â†’ CF   â”‚
â”‚ ROL      â”‚ Left (circ) â”‚ MSB â†’ LSB    â”‚ MSB â†’ CF   â”‚
â”‚ ROR      â”‚ Right (circ)â”‚ LSB â†’ MSB    â”‚ LSB â†’ CF   â”‚
â”‚ RCL      â”‚ Left (CF)   â”‚ CF â†’ LSB     â”‚ MSB â†’ CF   â”‚
â”‚ RCR      â”‚ Right (CF)  â”‚ CF â†’ MSB     â”‚ LSB â†’ CF   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ **Arithmetic Uses**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      SHIFT/ROTATE AS MULTIPLICATION/DIVISION   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MULTIPLICATION BY POWERS OF 2:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SHL AL, 1    ; AL Ã— 2
SHL AL, 2    ; AL Ã— 4
SHL AL, 3    ; AL Ã— 8

Example:
AL = 5 (0000 0101)
SHL AL, 2
= 20 (0001 0100) âœ…  (5 Ã— 4 = 20)


DIVISION BY POWERS OF 2:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SHR AL, 1    ; AL Ã· 2 (unsigned)
SAR AL, 1    ; AL Ã· 2 (signed)

Example (unsigned):
AL = 20 (0001 0100)
SHR AL, 2
= 5 (0000 0101) âœ…  (20 Ã· 4 = 5)


âš ï¸ IMPORTANT:
Use SAR for signed division
Use SHR for unsigned division
```

---

# ğŸ§ª **PART 4: COMPLETE WORKED EXAMPLES**

## **Example 1: Flag Analysis**

```
PROBLEM:
â”€â”€â”€â”€â”€â”€â”€â”€
AL = 80h (1000 0000)
BL = 80h (1000 0000)
ADD AL, BL

Find all flags.

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Binary addition
   1000 0000  (80h = -128 signed, 128 unsigned)
 + 1000 0000  (80h = -128 signed, 128 unsigned)
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
(1)0000 0000  (00h)
 â†‘
Carry out

STEP 2: Analyze each flag

CF (Carry):
  Carry out of MSB? YES
  CF = 1 âœ…

PF (Parity):
  AL = 0000 0000
  Count 1s: 0 (even)
  PF = 1 âœ…

AF (Auxiliary):
  Low nibbles: 0000 + 0000
  Carry from bit 3? NO
  AF = 0 âœ…

ZF (Zero):
  Result = 0?
  ZF = 1 âœ…

SF (Sign):
  MSB = 0
  SF = 0 âœ…

OF (Overflow):
  Signed: -128 + (-128) = -256
  Should be negative but result is 0!
  OF = 1 âœ… (signed overflow!)

FINAL FLAGS:
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ CF â”‚ 1 â”‚
â”‚ PF â”‚ 1 â”‚
â”‚ AF â”‚ 0 â”‚
â”‚ ZF â”‚ 1 â”‚
â”‚ SF â”‚ 0 â”‚
â”‚ OF â”‚ 1 â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”˜
```

---

## **Example 2: Masking â€” Clear Sign Bit**

```
PROBLEM:
â”€â”€â”€â”€â”€â”€â”€â”€
AL = 1101 0110 (D6h)
Clear bit 7 (sign bit), keep others

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Design mask
Want to clear: bit 7
Mask = 0111 1111 (7Fh)
       â†‘
     0 clears

STEP 2: Apply AND
    1101 0110  (AL)
AND 0111 1111  (Mask)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    0101 0110  (Result)
    â†‘
  Cleared!

CODE:
AND AL, 7Fh

VERIFICATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Before: AL = 1101 0110
After:  AL = 0101 0110 âœ…
Bit 7 cleared âœ…
Others preserved âœ…
```

---

## **Example 3: Masking â€” Set MSB and LSB**

```
PROBLEM:
â”€â”€â”€â”€â”€â”€â”€â”€
AL = 0010 1100
Set bits 7 and 0, keep others

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

STEP 1: Design mask
Want to set: bits 7, 0
Mask = 1000 0001 (81h)
       â†‘       â†‘
     1 sets  1 sets

STEP 2: Apply OR
   0010 1100  (AL)
OR 1000 0001  (Mask)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1010 1101  (Result)
   â†‘       â†‘
  Set!    Set!

CODE:
OR AL, 81h

VERIFICATION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Before: AL = 0010 1100
After:  AL = 1010 1101 âœ…
Bits 7,0 set âœ…
Others preserved âœ…
```

---

## **Example 4: Shift â€” Multiply by 8**

```
PROBLEM:
â”€â”€â”€â”€â”€â”€â”€â”€
AL = 5
Multiply by 8 using shift

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

5 Ã— 8 = 5 Ã— 2Â³
      = SHL 3 times

STEP 1: Initial
AL = 0000 0101 (5)

STEP 2: SHL AL, 3
or
SHL AL, 1
SHL AL, 1
SHL AL, 1

After 1st shift:
0000 1010 (10)

After 2nd shift:
0001 0100 (20)

After 3rd shift:
0010 1000 (40)

RESULT: AL = 40 âœ… (5 Ã— 8 = 40)

CODE:
MOV AL, 5
SHL AL, 3    ; or use CL for count > 1
```

---

## **Example 5: Rotate â€” Swap Nibbles**

```
PROBLEM:
â”€â”€â”€â”€â”€â”€â”€â”€
AL = 1010 0011
Swap high and low nibbles

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

Use ROL 4 (rotate left 4 positions)

STEP 1: Initial
AL = 1010 0011
     â””â”€â”˜ â””â”€â”˜
     High Low

STEP 2: ROL AL, 4
Move each bit 4 positions left (circular)

Position mapping:
Bit 7 â†’ Bit 3
Bit 6 â†’ Bit 2
Bit 5 â†’ Bit 1
Bit 4 â†’ Bit 0
Bit 3 â†’ Bit 7
Bit 2 â†’ Bit 6
Bit 1 â†’ Bit 5
Bit 0 â†’ Bit 4

Result:
AL = 0011 1010
     â””â”€â”˜ â””â”€â”˜
     Old  Old
     Low  High

SWAPPED! âœ…

CODE:
MOV CL, 4
ROL AL, CL
```

---

## **Example 6: RCL â€” Multi-Word Rotation**

```
PROBLEM:
â”€â”€â”€â”€â”€â”€â”€â”€
Rotate 16-bit value in AX left by 1
using 8-bit operations on AH, AL

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

AX = AH:AL = 1010 1100 : 0011 0110

APPROACH:
1. Rotate AL left through carry
2. Rotate AH left through carry
   (carry from AL goes to AH!)

STEP 1: Initial
CF = 0
AH = 1010 1100
AL = 0011 0110

STEP 2: RCL AL, 1
  0011 0110 with CF=0
  â†“
  0110 1100 with CF=0
  (MSB was 0, goes to CF)

STEP 3: RCL AH, 1
  1010 1100 with CF=0
  â†“
  0101 1000 with CF=1
         â†‘
      Old CF from AL

FINAL:
CF = 1
AH = 0101 1000
AL = 0110 1100

Effectively rotated entire 16-bit
value left by 1! âœ…

CODE:
CLC
RCL AL, 1
RCL AH, 1
```

---

# ğŸ§  **MEMORY AIDS & TRICKS**

## **Flag Mnemonics**

```
"Can People Actually Zero So Often?"
 â†“    â†“      â†“      â†“    â†“  â†“
 CF   PF     AF     ZF   SF OF

Or:

"Crazy Programmers Always Zero Strange Operations"
```

---

## **Masking Memory**

```
CLEAR â†’ AND â†’ 0 clears
"AND with zero, bit must go"

SET â†’ OR â†’ 1 sets
"OR with one, bit is won"

TOGGLE â†’ XOR â†’ 1 flips
"XOR with one, bit is done"
```

---

## **Shift/Rotate Memory**

```
SHL = Shift High Left
SHR = Shift High Right
SAR = Sign Arithmetic Right

ROL = Roll Over Left
ROR = Roll Over Right
RCL = Roll Carry Left
RCR = Roll Carry Right

LEFT shifts multiply (Ã—2)
RIGHT shifts divide (Ã·2)
```

---

# ğŸ“ **COMPLETE CHEAT SHEET**

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         MICROPROCESSOR QUICK REFERENCE             â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                    â•‘
â•‘ FLAGS:                                             â•‘
â•‘ â”€â”€â”€â”€â”€â”€                                             â•‘
â•‘ CF = Carry (unsigned overflow, bit 0)              â•‘
â•‘ PF = Parity (even 1s in low byte, bit 2)           â•‘
â•‘ AF = Auxiliary (carry bit 3â†’4, bit 4)              â•‘
â•‘ ZF = Zero (result=0, bit 6)                        â•‘
â•‘ SF = Sign (MSB, bit 7)                             â•‘
â•‘ OF = Overflow (signed overflow, bit 11)            â•‘
â•‘                                                    â•‘
â•‘ CF vs OF:                                          â•‘
â•‘ â€¢ CF â†’ unsigned problems                           â•‘
â•‘ â€¢ OF â†’ signed problems                             â•‘
â•‘                                                    â•‘
â•‘ LOGIC OPERATIONS:                                  â•‘
â•‘ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â•‘
â•‘ AND: Both 1 â†’ 1                                    â•‘
â•‘ OR:  Either 1 â†’ 1                                  â•‘
â•‘ XOR: Different â†’ 1                                 â•‘
â•‘ NOT: Flip all bits                                 â•‘
â•‘                                                    â•‘
â•‘ MASKING:                                           â•‘
â•‘ â”€â”€â”€â”€â”€â”€â”€â”€                                           â•‘
â•‘ Clear bits: AND with 0                             â•‘
â•‘ Set bits:   OR with 1                              â•‘
â•‘ Toggle bits: XOR with 1                            â•‘
â•‘ Test bits:  TEST (AND without storing)             â•‘
â•‘                                                    â•‘
â•‘ SHIFTS:                                            â•‘
â•‘ â”€â”€â”€â”€â”€â”€â”€                                            â•‘
â•‘ SHL/SAL: Left, LSBâ†0, MSBâ†’CF, Ã—2                   â•‘
â•‘ SHR:     Right, MSBâ†0, LSBâ†’CF, Ã·2 unsigned         â•‘
â•‘ SAR:     Right, MSBâ†sign, LSBâ†’CF, Ã·2 signed        â•‘
â•‘                                                    â•‘
â•‘ ROTATES:                                           â•‘
â•‘ â”€â”€â”€â”€â”€â”€â”€â”€                                           â•‘
â•‘ ROL: Left circular, MSBâ†’LSB & CF                   â•‘
â•‘ ROR: Right circular, LSBâ†’MSB & CF                  â•‘
â•‘ RCL: Left through CF (9-bit rotation)              â•‘
â•‘ RCR: Right through CF (9-bit rotation)             â•‘
â•‘                                                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

# âœ… **PRACTICE PROBLEMS WITH SOLUTIONS**

## **Problem 1: Flags**

```
QUESTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
AL = 7Fh, BL = 01h
ADD AL, BL
Find: CF, ZF, SF, OF

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
   0111 1111  (127 signed, 127 unsigned)
 + 0000 0001  (1)
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1000 0000  (128 unsigned, -128 signed)

CF = 0 (no carry out)
ZF = 0 (result â‰  0)
SF = 1 (MSB = 1)
OF = 1 (pos + pos = neg!) âœ…

ANSWER:
CF=0, ZF=0, SF=1, OF=1
```

---

## **Problem 2: Masking**

```
QUESTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
AL = 0110 0110
Set bits 7, 4, 0. Others unchanged.

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
Mask = 1001 0001 (91h)
       â†‘  â†‘    â†‘
     Set positions

   0110 0110  (AL)
OR 1001 0001  (Mask)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1111 0111  (Result)

CODE: OR AL, 91h

ANSWER: AL = F7h
```

---

## **Problem 3: Shift**

```
QUESTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
BL = 1011 0111
ROL BL, 1
Then ROR BL, 2
Final BL = ?

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

Initial: BL = 1011 0111

After ROL 1:
 MSB wraps to LSB
 BL = 0110 1111
 CF = 1

After ROR 2:
 First ROR:
  LSB wraps to MSB
  BL = 1011 0111
  CF = 1
 
 Second ROR:
  BL = 1101 1011
  CF = 1

ANSWER: BL = DBh, CF = 1
```

---

## **Problem 4: Logic**

```
QUESTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€
AL = 0110 0110
AND AL, 1111 0000
Result? Flags?

SOLUTION:
â”€â”€â”€â”€â”€â”€â”€â”€â”€

   0110 0110  (AL)
AND 1111 0000  (Mask)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   0110 0000  (Result)

FLAGS:
CF = 0 (AND clears CF)
OF = 0 (AND clears OF)
ZF = 0 (result â‰  0)
SF = 0 (MSB = 0)
PF = 0 (0110 0000 has 2 ones = even)
       Wait: 2 is even â†’ PF = 1 âœ…

ANSWER: AL = 60h
        CF=0, OF=0, ZF=0, SF=0, PF=1
```

---

**ğŸ“ You now have COMPLETE MASTERY of 8086 Flags, Logic Instructions, and Shift/Rotate operations! Ready to dominate microprocessor programming! ğŸš€ğŸ’»**
